from django.apps import apps
from rest_framework import viewsets, status, exceptions, viewsets, serializers
from rest_framework.permissions import IsAuthenticated, AllowAny
from rest_framework_simplejwt.authentication import JWTAuthentication
from rest_framework.exceptions import PermissionDenied
from .serializers import *
from django.db import transaction
from bson import ObjectId
import json
from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework.views import APIView
from django.contrib.auth import authenticate
from rest_framework_simplejwt.exceptions import TokenError
from rest_framework_simplejwt.tokens import RefreshToken
from rest_framework.renderers import JSONRenderer
from Root.models import *

class ObjectIdEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, ObjectId):
            return str(obj)
        return super().default(obj)

class ObjectIdRenderer(JSONRenderer):
    encoder_class = ObjectIdEncoder

    def render(self, data, accepted_media_type=None, renderer_context=None):
        if data is None:
            return bytes()
        try:
            ret = json.dumps(data, cls=self.encoder_class)
            return ret.encode()
        except TypeError as e:
            print("ðŸ”¥ Serialization Error:", data)
            raise e

class BaseModelViewSet(viewsets.ModelViewSet):
    authentication_classes = [JWTAuthentication]
    permission_classes = [IsAuthenticated]

    def get_permissions(self):
        if self.action in ['update', 'partial_update']:
            if not self.request.user.has_perm(f"{self.queryset.model._meta.app_label}.change_{self.queryset.model._meta.model_name}"):
                raise PermissionDenied
        elif self.action == 'destroy':
            if not self.request.user.has_perm(f"{self.model._meta.app_label}.delete_{self.model._meta.model_name}"):
                raise PermissionDenied
        elif self.action in ['list', 'retrieve']:
            if not self.request.user.has_perm(f"{self.model._meta.app_label}.view_{self.model._meta.model_name}"):
                raise PermissionDenied
        elif self.action == 'create':
            if not self.request.user.has_perm(f"{self.model._meta.app_label}.add_{self.model._meta.model_name}"):
                raise PermissionDenied
        return super().get_permissions()

    def get_queryset(self):
        return super().get_queryset()

    def perform_create(self, serializer):
        serializer.save()

    def perform_update(self, serializer):
        serializer.save()

    def perform_destroy(self, instance):
        instance.delete()

class AutoGeneratedViewSet(viewsets.ModelViewSet):
    lookup_field = 'id'
    lookup_value_regex = '[0-9a-f]{24}'

    @transaction.atomic
    def perform_create(self, serializer):
        serializer.save()

    @transaction.atomic
    def perform_update(self, serializer):
        serializer.save()

    @transaction.atomic
    def perform_destroy(self, instance):
        instance.delete()

    def create(self, request, *args, **kwargs):
        user = request.user
        if not user or not user.is_authenticated:
            return Response({"detail": "Authentication credentials were not provided."}, status=401)
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        try:
            instance = serializer.save()
            data = self.get_serializer(instance).data
            return Response(data, status=201)
        except Exception as e:
            if 'instance' in locals():
                instance.delete()
            raise e

# Dynamically generate views and serializers for each model
models = apps.get_models()
for model in models:
    model_name = model.__name__.lower()

    # Dynamically create serializer class
    serializer_meta = type('Meta', (), {'model': model, 'fields': '__all__'})
    serializer_class = type(f'{model_name}Serializer', (serializers.ModelSerializer,), {'Meta': serializer_meta})

    # Dynamically create ViewSet class
    viewset_class = type(f'{model_name}ViewSet', (AutoGeneratedViewSet,), {
        'serializer_class': serializer_class,
        'queryset': model.objects.all(),
        'model': model
    })

    # Add the dynamically created classes to globals
    globals()[f'{model_name}Serializer'] = serializer_class
    globals()[f'{model_name}ViewSet'] = viewset_class

class ExampleView(APIView):
    permission_classes = [IsAuthenticated]
    def get(self, request):
        user = request.user
        data = { 
            'username': user.username,
            'email': user.email,
            'first_name': user.first_name,
            'last_name': user.last_name,
        }
        return Response(data)

class LoginView(APIView):
    permission_classes = [AllowAny]

    def post(self, request):
        serializer = LoginSerializer(data=request.data)
        if serializer.is_valid():
            email = serializer.validated_data['email']
            password = serializer.validated_data['password']

            # Manually authenticate user using email
            user = authenticate(request, username=email, password=password)
            if user is not None:
                # Generate JWT token
                refresh = RefreshToken.for_user(user)
                access_token = str(refresh.access_token)

                # Ensure user has a related customer object, if applicable
                try:
                    customer_id = user.customer.id  # Assuming you have a related Customer model
                except AttributeError:
                    customer_id = None  # Handle if customer doesn't exist

                # Prepare user data for response
                user_data = {
                    'id': str(user.id),
                    'name': user.get_full_name(),  # Use get_full_name() or user.username
                    'customer_id': customer_id,
                    'isSuperAdmin': user.is_superuser,
                }

                # Determine user role
                role = "ADMIN" if user.is_superuser else "USER"

                return Response({
                    'user': user_data,
                    'token': access_token,
                    'role': role,
                }, status=status.HTTP_200_OK)
            else:
                return Response({'error': 'Invalid email or password'}, status=status.HTTP_401_UNAUTHORIZED)
        else:
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

class TokenRefreshView(APIView):
    def post(self, request):
        refresh_token = request.data.get('refresh')
        try:
            refresh = RefreshToken(refresh_token)
            access_token = refresh.access_token
            return Response({'access': str(access_token)})
        except TokenError:
            return Response({'error': 'Invalid refresh token'}, status_code=401)

class CustomJWTAuthentication(JWTAuthentication):
    def get_user(self, validated_token):
        """
        Returns the user associated with the given token, if any.
        """
        try:
            user_id = validated_token['user_id']
            return User.objects.get(pk=user_id)
        except User.DoesNotExist:
            return None
        
    def authenticate(self, request):
        # Get the Authorization header from the request
        header = self.get_header(request)
        if header is None:
            return None

        # Get the raw token from the header
        raw_token = self.get_raw_token(header)
        if raw_token is None:
            return None

        # Validate the token
        validated_token = self.get_validated_token(raw_token)
        print(validated_token)
        if not validated_token:
            raise exceptions.AuthenticationFailed(
                'Invalid or expired token',
                code=status.HTTP_401_UNAUTHORIZED
            )

        # Get the user from the validated token
        user = User.objects.get(pk=validated_token['user_id'])
        if not user:
            raise exceptions.AuthenticationFailed(
                'User not found',
                code=status.HTTP_401_UNAUTHORIZED
            )

        # Return the user and the validated token
        return (user, validated_token)

class SensorAPIView(APIView):
    authentication_classes = [CustomJWTAuthentication]
    permission_classes = [IsAuthenticated]

    def post(self, request, *args, **kwargs):
        """
        Handle the POST request for creating a new sensor. This will
        validate the data and return an appropriate response.
        """
        print("Incoming request data:", request.data)  # Debug print to check incoming data

        # You can modify the request data if necessary (e.g., to handle objectId conversion)
        # For instance, if you need to convert string bearingLocationId to ObjectId, do it here

        # Handle validation with the sensor serializer
        serializer = SensorSerializer(data=request.data)

        # Check if the data is valid
        if serializer.is_valid():
            print("Valid data:", serializer.validated_data)  # Debug print to check validated data

            try:
                # Save the sensor object after validation
                sensor = serializer.save()
                print("Sensor saved successfully:", sensor)

                # Return the created sensor data
                return Response(serializer.data, status=status.HTTP_201_CREATED)

            except Exception as e:
                # In case of any error, log it and return a 500 error
                print("Error while saving the sensor:", e)
                return Response({"error": "Error saving the sensor"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
        else:
            print("Validation errors:", serializer.errors)  # Debug print to check validation errors
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        
class MachineViewSet(viewsets.ModelViewSet):
    queryset = Machine.objects.all()
    serializer_class = MachineSerializer

class BearingLocationViewSet(viewsets.ModelViewSet):
    queryset = BearingLocation.objects.all()
    serializer_class = BearingLocationSerializer

    def list(self, request, *args, **kwargs):
        # Call the original list method
        return super().list(request, *args, **kwargs)

    def create(self, request, *args, **kwargs):
        return super().create(request, *args, **kwargs)
    
class UserViewSet(viewsets.ModelViewSet):
    id = ObjectIdField(read_only=True)
    queryset = User.objects.all()
    serializer_class = UserSerializer

    def perform_create(self, serializer):
        customer_id = self.request.data.get('customerId')
        if customer_id:
            try:
                customer = Customer.objects.get(id=ObjectId(customer_id))
                serializer.save(customerId=customer)
            except Customer.DoesNotExist:
                raise ValidationError("Invalid customerId")
        else:
            serializer.save()

class AlertLimitsViewSet(viewsets.ModelViewSet):
    queryset = AlertLimits.objects.all()
    serializer_class = AlertLimitsSerializer
    pagination_class = None